- GESTIONE DISCO DB2
	- CONTAINER
		- unita di un tablespace, può essere un disco o un **file**
		- diviso in EXTENTS
			- pagine contigue di dimensione 4Kb
	- TABLE SPACE
	  id:: 64047a90-f81f-418a-8d2a-d10974ed09f2
		- TODO aggiungere definizione
		  :LOGBOOK:
		  CLOCK: [2023-03-01 Wed 11:45:51]--[2023-03-01 Wed 11:45:52] =>  00:00:01
		  :END:
		- il tablespace è uno spazio logico che puo contenere 1 o
		- possibile specificare parametri
		- sono minimo 3
			- USER TABLES
			- CATALOGS (metainformazioni per il DB)
			- TEMPORARY TABLES (necessari per lo swap delle pagine tra memoria centrale e disco)
		- possibili tipologie
			- SMS
				- (la memorizzazione e gestita da OS)
				- CREATE TABLESPACE ... MANAGED BY SYSTEM
				- impossibilita di modificare i container
				- DIMENSIONE MASSIMA numero di file * dimensione massima singolo file
			- DMS
			  id:: 63ff283b-7769-4172-8e68-ebf166d3f255
				- (il database administrator gestisce la memoria)
				- CREATE TABLESPACE ... MANAGED BY DATABASE
				- possibile creare o rimuovere containers
					- il bilanciamento in caso di creazione o rimozione è autiomatico (il dbms distribuisce i dati del tablespace in maniera equa in tutti i container)
				- DIMENSIONE MASSIMA 512 gb
			- Automatic Storage
				- (il dbms gestisce la memoria)
				- scelta sicura ma poco ottimizzata per impossibilita del DBMS di conoscere il progetto fisico, per ottimizzazioni necessaria ((63ff283b-7769-4172-8e68-ebf166d3f255))
				- modifica dei container automatizzata
					- bilanciamento automatizzato
				- DIMENSIONE MASSIMA = dimensione del filesystem
			- SEPARAZIONE TRA I CONTENUTI
				- SMS
					- no separazione
				- DMS
					- gli oggetti (indici e tabelle) possono essere contenuti in tablespace differenti
				- AS
					- gli oggetti (indici e tabelle) possono essere contenuti in tablespace differenti
			- TRE SISTEMI A CONFRONTO
				- AS
					- tabelle grandi
					- gestione semplificata
					- poco controllo
				- DMS
					- tabelle grandi
					- controllo elevato
				- SMS
					- controllo delegato al OS
		- perche non usare i servizi del filesistem?
			- il filesistem offre servizi facendo assunzioni sull'utilizzo della memoria da parte delle applicazioni che ne fanno uso
			- assunzioni non valgono per un DBMS
			- per un DBMS è necessario sfruttare le relazioni fra le informazioni in fase di memorizzazione delle stesse per rendere le query di estrazione piu veloci
				- esempi
					- se due relazioni sono collegate da un JOIN salvare in container contigui è una buona idea
					- se in una relazione sono presenti dati BLOB salvarli in un altro container è una buona idea
			- **IL FILESYSTEM NON È A CONOSCENZA DI QUESTE NECESSITÀ DEL DBMS**
		- STRUTTURA DI UN CONTAINER
			- presente un header
			- le tuple sono organizzate in righe di file
			- gli attributi sono in ordine sequenzialmente
			- insiemi di tuple vengono organizzati in pagine
			- RAPPRESENTAZIONE DEI DATI
				- char
					- si usa un numero di byte pari a quanto richiesto dalla tabella
				- varchar
					- numero di caratteri seguiti dalla codifica
				- DATE TIME
					- memorizzati come interi, mostrati all'esterno come stringhe
				- vengono memorizzati anche gli offset degli attributi dei record per facilitare le query
				- vengono memorizzati:
					- lunghezza del record
					- indirizzi di inizio dei campi variabili
					- campi a lunghezza fissa
					- campi a lunghezza variabile
					- questi campi aumentano la dimensione del record ma consentono di velocizzare le query
				- viene memorizzato anche un header del record
					- ID della relazione a cui il record appartiene
					- ID del record all'interno del DB
				- normalmente un record è contenuto nella dimensione massima della pagina
		- ORGANIZZAZIONE DELLA PAGINA
			- header
			- directory
				- contiene un puntatore per ogni record di cui fa parte
				- id di un record (RID) composto da
					- PID (page identifier)
					- Slot (location all'interno della directory)
				- le directory non sono ordinate
				- in questo modo è possibile organizzare i record all'interno delle pagine senza modificare il RID
				- le query di ricerca tramite RID sono facilitate
				- gli indici contengono elenchi di RID
				- INSERIMENTO DEI RECORD
				  id:: 63ff3f12-8bb9-4cc4-8629-7143a862e628
					- in memoria centrale viene aggiunto il record nel primo spazio libero
					- se lo spazio non è sufficiente e è presente spazio vuoto allora i record all'interno della directory viene riorganizzato (grazie al RID è possibile spostarlo senza problemi)
				- MODIFICA DEI RECORD
					- RECORD OVERFLOW
						- cosa succede quando la modifica di un record eccede la dimensione della pagina?
						- si inserisce al posto del record la sua vera posizione e si sposta il record in un altra pagina
						- peggioramento delle performance
		- LETTURA E SCRITTURA PAGINE
			- operazione che consiste nello spostare pagine da memoria secondaria a memoria centrale
			- buffer
				- aree di memoria centrale chiamate
				- BUFFER SU MEMORIA = PAGINA SU DISCO
			- gestione del buffer delegata al **BUFFER MANAGER**
			- BUFFER MANAGER
				- la strategia applicata dal buffer manager è fondamentale per
					- le performance
					- persistenza dei dati nelle transazioni
				- quando viene richiesta una pagina
					- se è presente in memoria centrale il BM restituisce l'indirizzo
					- se la pagina non è presente in memoria centrale
						- viene selezionato un buffer per il caricamento della pagina
						- se il buffer selezionato è occupato da un altra pagina, viene salvato solo se modificato e utilizzato per il caricamento della nuova pagina
							- la pagina selezionata è quella che è stata utlizzata l'ultima volta da meno tempo (MRU)( seguendo i ((63f75851-5c6f-4200-b880-089c170b6e2e)) al contrario)
								- questo per ottimizzare le letture e i JOIN
							- è possibile variare la politica di gestione del buffer pool per in fase di creazione del table space
								- più flessibilità rispetto alla gestione della memoria del OS
								-
				- interfaccia del BUFFER MANAGER
					- getAndPinPage()
						- viene richiesta una pagina al buffer manager
						- viene anche contrassegnata come occupata tramite un intero che indica quanti utilizzatori stanno utilizzando la pagina
					- unPinPage()
						- la pagina viene contrassegnata come non in utilizzo
					- setDirty()
						- la pagina viene contrassegnata come modificata
						- il contenuto della pagina non corrisponde con cosa c'è nel disco
					- flushPage()
						- viene forzato il salvataggio della pagina in memoria centrale
						- non consentito a tutti gli utilizzatori
						- il buffer non viene liberato
		- ORGANIZZAZIONE DEI FILE
			- per semplicità si considerano
				- record di lunghezza fissa
				- costo delle operazioni come numero di I/O operation condotte assumendo che il caricamento di una pagina sia un unica I/O operation
				- STIMA DEL COSTO DELLE OPERAZIONI
					- le operazioni interessanti sono
						- ricerca per chiave
						  id:: 30b627f4-65be-4a0f-896b-03e36d69e9e1
						- ricerca per range
						  id:: 7b6cdc6d-baf3-4a1a-83f7-7720b9276cf4
						- inserimento di un record
						- eliminazione di un record
						  id:: f24aed1c-ffca-40d0-9921-2370d5a1642d
						- aggiornamento di un attributo in un record
						  id:: f4e40e86-1149-4a56-9d40-db088c43e031
					-
			- HEAP FILE
			  id:: 63ff4567-cdb6-48fa-a823-d6bb8bf62a9c
				- i dati vengono inseriti senza particolare ordine
			- SEQUENTIAL FILE
			  id:: 63ff461e-09e6-4ad9-8172-b9461cfe0adc
			- all'interno dei catalog vengono memorizzate
				- tabella
				- numero di pagine della tabella
				- id della tabella
				- nome dei campi