- ### LOAD FACTOR
	- data una stima dei record N una capacita C si determina il load factor d
	- #### imposizioni
		- necessario che un bucket sia caricabile con una sola operazione di IO
		- il costo del trasferimento di un bucket di capacità C deve costare meno del trasferimento di due bucket di capacita minore di C
	- #### GESTIRE OVERFLOW
		- ##### STRATEGIE
			- ###### chaining
				- liste separate
					- tutti i record sono linkati in una lista
					- ![image.png](../assets/image_1678966949021_0.png)
				- concatenamento convergente
					- si usa un solo puntatore per bucket
					- i bucket sono collegati a lista
					- prestazioni peggiori ma ottimizzazione della memoria
					- ![image.png](../assets/image_1678966966648_0.png){:height 241, :width 253}
			- ###### open addressing
				- non vengono usati puntatori
				- a una chiave viene associata una lista di indirizzi
				- quando si inserisce un valore di chiave si testano tutti gli indirizzi finchè non si trova l'indirizzo di un bucket non pieno
			- ###### linear probing
				- a ogni step l'indirizzo viene aumentato di un valore costante
				- ![image.png](../assets/image_1678967776836_0.png)
				- ###### primary clustering
					- se un bucket va in overflow anche il bucket+P è probabile che vada in overflow
			- ###### quadratic probing
				- a ogni step l'indirizzo viene aumentato di un valore lineare
				- resta comunque il problema delle chiavi
			- ###### double hashing
				- vengono utilizzate due funzioni hash
				- ![image.png](../assets/image_1678968075708_0.png)
		- #### COSTI
			- ![image.png](../assets/image_1678968155318_0.png)
- ### PROBLEMATICHE DELLA ORGANIZZAZIONE STATICA
	- è complesso stimare il dimensionamento degli indici hash
		- se si sovrastima la dimensione dell'area primaria si ha un pessimo utilizzo della memoria
		- se si sottostima si hanno pessime performance dovute hai continui accessi all'area di overflow
- ### HASH DINAMICO
	- la dimensione dell'area primaria è calcolata dinamicamente
	- se un bucket va in overflow l'area primaria viene ampliata
		- viene raddoppiato il codominio della funzione hash
		- non necessariamente raddoppia l'area primaria
		- necessario specificare quali bucket sono utilizzati
	- se vengono eliminati dei record l'area primaria viene ridotta
	- ### tipologie
		- #### con directory
		- #### senza directory
			- ##### linear hashing
				- viene effettuato lo split dei bucket secondo un criterio lineare
				- viene splittato il bucket succesivo all'ultimo splittato
				- quando si verifica l'ìoverflow viene creato un bucket al, indirizzo P0+ PS
				- i record vengono redistribuiti tramite la nuova funzione hash
				- H(k)= k% (2P0)
				- durante la ricerca del record viene scelta la funzione hash in base a se il bucket sia splittato o meno
				- ##### caratteristiche
					- basso utilizzo della memoria
						- soluzione imporre limite minimo per l'operazione di split
						- ![image.png](../assets/image_1678969778303_0.png)
						- contro si alzano i costi e aumenta l'utilizzo dell'area di overflow
						- ![image.png](../assets/image_1678969861747_0.png)
						-
					- problemi con la gestione dei bucket in overflow area
						- soluzione, gestione tramite **linear hashing ricorsivo**
				- #### problematica di gestione dell'overflow
					- i bucket in fondo allo spazio di indirizzamento vengono splittati in ritardo e aumenta il loro overflow
					- soluzione: usare una funzione hash che aumenta la probabilità di uscita dei bucket successivi allo split pointer
					- ##### spiral hashing
					- ![image.png](../assets/image_1678970294044_0.png)
- # TRANSAZIONI
	- operazioni logiche che portano il DB da uno stato consistente ad un altro
	- rispettano le proprieta ACID
	- #### ATOMICITY
		- la transazione non può essere interrotta da altra operazioni
	- #### CONCISTENCY
		- il db alla fine della transazione deve trovarsi in uno stato consistente (i vincoli definiti sul db non devono essere violati)
	- #### ISOLATION
		- l'esecuzione di una transazione non deve interferire con l'esecuzione di un altra
	- #### DURABILITY PERCISTANCE
		- le modifiche apportate da una transazione devono essere persistenti
-